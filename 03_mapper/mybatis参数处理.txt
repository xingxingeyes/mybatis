单个参数：mybatis不会做特殊处理
    #{参数名}，取出参数值

多个参数：mybatis会做特殊处理
    多个参数会被封装成一个map
        key：param1...paramN，或者参数的索引也可以
        value:传入的参数值
    #{}就是从map中获取指定的key的值
    异常：
    	org.apache.ibatis.binding.BindingException:
    	Parameter 'id' not found.
    	Available parameters are [1, 0, param1, param2]
    操作：
        方法：public Employee getEmpByIdAndLastName(Integer id,String lastName);
        取值：#{id},#{lastName}



命名参数：明确指定封装参数是map的key：@Param("id")
    多个参数会被封装成一个map，
        key：使用@Param注解指定的值
        value：参数值
    #{指定的key}取出对应的参数值

POJO：
如果多个参数正好是我们业务逻辑的数据模型，我们就可以直接传入pojo；
	#{属性名}：取出传入的pojo的属性值

Map：
如果多个参数不是业务模型中的数据，没有对应的pojo，不经常使用，为了方便，我们也可以传入map
	#{key}：取出map中对应的值

TO：
如果多个参数不是业务模型中的数据，但是经常要使用，推荐来编写一个TO（Transfer Object）数据传输对象
Page{
	int index;
	int size;
}

=======================================思考===================================
public Employee getEmp(@Param("id")Integer id,String lastName);
            取值：id===>#{id/param1} lastName===>#{param2}
public Employee getEmp(Integer id,@Param("e")Employee emp);
            取值：id===>#{param1} lastName===>#{e.lastName/param2.lastName}
##特别注意：如果是Collection(List、Set)类型或者是数组，
                也会特殊处理。也是吧传入的list或者数组封装在map中。
                            key:Collection(collection),如果是List还可以使用这个key(list)
                                        数组(array)
public Employee getEmpById(List<Integer> ids);
            取值：取出第一个id的值： #{list[0]}
===================================结合源码，mybatis怎么处理参数==================
  ParamNameResolver解析参数封装map的；
  //1.names:{0=id, 1=lastName}
        1.获取每个标了param注解的参数的param值：id,lastName; 赋值给name；
        2.每次解析一个参数给map中保存信息，（key:参数索引，value：name的值）
            name的值：
                标注的param注解：注解的值
                没有标注：
                        1.全局配置：useActualParamName(jdk1.8):name=参数名
                        2.name=map.size();相当于元素的索引
       {0=id,1=laseName,2=2}


    public Object getNamedParams(Object[] args) {
        int paramCount = this.names.size();
        //1、参数为null直接返回
        if (args != null && paramCount != 0) {
            //2、如果只有一个元素，并且没有Param注解；args[0]:单个参数直接返回
            if (!this.hasParamAnnotation && paramCount == 1) {
                return args[(Integer)this.names.firstKey()];
            } else {
            //3、多个元素或者有Param标注
                Map<String, Object> param = new ParamMap();
                int i = 0;
            //4、遍历names集合；{0=id, 1=laseName, 2=2}
                for(Iterator i$ = this.names.entrySet().iterator(); i$.hasNext(); ++i) {
                    Entry<Integer, String> entry = (Entry)i$.next();
                    //names集合的value作为key；names集合的key又作为取值的参考args[0]:args【1,"Tom"】
                    //eg:{id=args[0]:1,lastName=args[1]:Tom,2=args[2]}
                    param.put(entry.getValue(), args[(Integer)entry.getKey()]);
                    // add generic param names (param1, param2, ...)param
                    //额外的将每一个参数也保存到map中，使用新的key：param1...paramN
                    //效果：有Param注解可以#{指定的key}，或者#{param1}
                    String genericParamName = "param" + String.valueOf(i + 1);
                    if (!this.names.containsValue(genericParamName)) {
                        param.put(genericParamName, args[(Integer)entry.getKey()]);
                    }
                }

                return param;
            }
        } else {
            return null;
        }
    }