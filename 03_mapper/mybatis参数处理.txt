单个参数：mybatis不会做特殊处理
    #{参数名}，取出参数值

多个参数：mybatis会做特殊处理
    多个参数会被封装成一个map
        key：param1...paramN，或者参数的索引也可以
        value:传入的参数值
    #{}就是从map中获取指定的key的值
    异常：
    	org.apache.ibatis.binding.BindingException:
    	Parameter 'id' not found.
    	Available parameters are [1, 0, param1, param2]
    操作：
        方法：public Employee getEmpByIdAndLastName(Integer id,String lastName);
        取值：#{id},#{lastName}



命名参数：明确指定封装参数是map的key：@Param("id")
    多个参数会被封装成一个map，
        key：使用@Param注解指定的值
        value：参数值
    #{指定的key}取出对应的参数值

POJO：
如果多个参数正好是我们业务逻辑的数据模型，我们就可以直接传入pojo；
	#{属性名}：取出传入的pojo的属性值

Map：
如果多个参数不是业务模型中的数据，没有对应的pojo，不经常使用，为了方便，我们也可以传入map
	#{key}：取出map中对应的值

TO：
如果多个参数不是业务模型中的数据，但是经常要使用，推荐来编写一个TO（Transfer Object）数据传输对象
Page{
	int index;
	int size;
}

=======================================思考===================================
public Employee getEmp(@Param("id")Integer id,String lastName);
            取值：id===>#{id/param1} lastName===>#{param2}
public Employee getEmp(Integer id,@Param("e")Employee emp);
            取值：id===>#{param1} lastName===>#{e.lastName/param2.lastName}
##特别注意：如果是Collection(List、Set)类型或者是数组，
                也会特殊处理。也是吧传入的list或者数组封装在map中。
                            key:Collection(collection),如果是List还可以使用这个key(list)
                                        数组(array)
public Employee getEmpById(List<Integer> ids);
            取值：取出第一个id的值： #{list[0]}
===================================结合源码，mybatis怎么处理参数==================
  ParamNameResolver解析参数封装map的；
  //1.names:{0=id, 1=lastName}
        1.获取每个标了param注解的参数的param值：id,lastName; 赋值给name；
        2.每次解析一个参数给map中保存信息，（key:参数索引，value：name的值）
            name的值：
                标注的param注解：注解的值
                没有标注：
                        1.全局配置：useActualParamName(jdk1.8):name=参数名
                        2.name=map.size();相当于元素的索引
       {0=id,1=laseName,2=2}


    public Object getNamedParams(Object[] args) {
        int paramCount = this.names.size();
        //1、参数为null直接返回
        if (args != null && paramCount != 0) {
            //2、如果只有一个元素，并且没有Param注解；args[0]:单个参数直接返回
            if (!this.hasParamAnnotation && paramCount == 1) {
                return args[(Integer)this.names.firstKey()];
            } else {
            //3、多个元素或者有Param标注
                Map<String, Object> param = new ParamMap();
                int i = 0;
            //4、遍历names集合；{0=id, 1=laseName, 2=2}
                for(Iterator i$ = this.names.entrySet().iterator(); i$.hasNext(); ++i) {
                    Entry<Integer, String> entry = (Entry)i$.next();
                    //names集合的value作为key；names集合的key又作为取值的参考args[0]:args【1,"Tom"】
                    //eg:{id=args[0]:1,lastName=args[1]:Tom,2=args[2]}
                    param.put(entry.getValue(), args[(Integer)entry.getKey()]);
                    // add generic param names (param1, param2, ...)param
                    //额外的将每一个参数也保存到map中，使用新的key：param1...paramN
                    //效果：有Param注解可以#{指定的key}，或者#{param1}
                    String genericParamName = "param" + String.valueOf(i + 1);
                    if (!this.names.containsValue(genericParamName)) {
                        param.put(genericParamName, args[(Integer)entry.getKey()]);
                    }
                }

                return param;
            }
        } else {
            return null;
        }
    }
==============================================参数值的获取==================================
#{}：可以获取map中的值或者pojo对象属性的值：
${}：可以获取map中的值或者pojo对象属性的值：
    区别：
        #{}：是以预编译的形式，将参数设置到sql语句中：PreparedSatement,
        ${}：取出的值直接拼装在sql语句中；会有安全问题；
        大多情况下，我们取参数的值都应该去使用#{}；
        原生jdbc不支持占位符的地方我们就使用${}进行取值
        比如分表、排序。。。按照年份分表拆分
            select * from ${year}_salary where xxx;
            select * from tbl_employee order by ${f_name} ${order}

#{}:更丰富的用法：
    规定参数的一些规则
    javaType、jdbcType、mode(存储过程)、numericScale、
    resultMap、typeHandler、jdbcTypeName、expression(未来准备支持的功能)

    jdbcType通常需要在某种特定的条件下被设置：
        在我们数据为null的时候，有些数据库可能不能识别mybatis对null的默认处理。比如Oracle(报错);

        JdbcType OTHER：无效类型：因为mybatis对所有的null都映射的是原生Jdbc的OTHER的类型，orcal不能真确处理;

        由于全局配置中：jdbcTypeForNull=OTHER:orcal不支持；
        1、#{email,jdbcType=OTHER};
        2、jdbcTypeForNull=NULL
                    <setting name="jdbcTypeForNull" value="NULL"/>
